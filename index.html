
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ian Ryan Smith - Portfolio</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet" />
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      color: #eee;
      background-color: #121212;
      line-height: 1.6;
      position: relative;
      overflow-x: hidden; /* Prevent horizontal scrolling */
      min-height: 100vh;
    }
    
    h2 {
      color: #bb86fc;
      margin-top: 40px;
      border-bottom: 2px solid #333;
      padding-bottom: 6px;
      user-select: none;
      white-space: nowrap;
      overflow: hidden; /* Prevent text overflow */
      font-size: clamp(1.2rem, 4vw, 1.5rem); /* Responsive font size */
    }
    
    section {
      background-color: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(187, 134, 252, 0.3);
      margin-top: 30px;
      width: 100%;
    }
    
    a {
      color: #bb86fc;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s ease;
      word-break: break-word; /* Prevent long links from overflowing */
    }
    
    a:hover,
    a:focus {
      color: #3700b3;
      text-decoration: underline;
    }
    
    ul {
      list-style: none;
      padding-left: 0;
    }
    
    li {
      margin-bottom: 12px;
    }
    
    p {
      font-size: clamp(1rem, 2.5vw, 1.1rem);
      margin-top: 10px;
    }
    
    /* Main title - responsive sizing */
    #text {
      font-size: clamp(2rem, 8vw, 3.5rem);
      user-select: none;
      white-space: nowrap;
      font-weight: 700;
      color: #bb86fc;
      margin-bottom: 20px;
      overflow: hidden; /* Prevent overflow */
    }
    
    #text span,
    h2 span {
      display: inline-block;
      transition: transform 0.1s ease-in-out;
      cursor: default;
    }
    
    #text span.space,
    h2 span.space {
      width: 0.3em;
    }
    
    /* Car - responsive sizing */
    #car {
      position: fixed;
      width: clamp(50px, 15vw, 135px);
      height: clamp(25px, 7.5vw, 67px);
      bottom: 20px;
      left: 20px;
      background: transparent;
      border-radius: 10px;
      z-index: 1001;
      user-select: none;
      pointer-events: none;
      display: none;
      font-size: clamp(25px, 7.5vw, 67px);
      line-height: 1;
      text-align: center;
      touch-action: none; /* Prevent default touch actions */
    }
    
    /* Enemies - responsive sizing */
    .enemy {
      position: fixed;
      width: clamp(15px, 4vw, 20px);
      height: clamp(15px, 4vw, 20px);
      background: #ff4444;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 8px #ff4444;
      user-select: none;
      pointer-events: none;
    }
    
    .special-enemy {
      position: fixed;
      width: clamp(6px, 1.5vw, 7.5px);
      height: clamp(6px, 1.5vw, 7.5px);
      background: #ffaa00;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 15px #ffaa00, 0 0 30px rgba(255, 170, 0, 0.5);
      user-select: none;
      pointer-events: none;
      animation: dramaticPulse 0.5s infinite alternate ease-in-out;
    }
    
    @keyframes dramaticPulse {
      0% { 
        transform: scale(0.8);
        box-shadow: 0 0 10px #ffaa00, 0 0 20px rgba(255, 170, 0, 0.3);
      }
      100% { 
        transform: scale(2.2);
        box-shadow: 0 0 25px #ffaa00, 0 0 50px rgba(255, 170, 0, 0.8), 0 0 75px rgba(255, 170, 0, 0.4);
      }
    }

    .boss-enemy {
      position: fixed;
      width: clamp(18px, 5vw, 25px);
      height: clamp(18px, 5vw, 25px);
      background: #0066ff;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7);
      user-select: none;
      pointer-events: none;
      animation: strobeFlash 0.1s infinite steps(2, start);
    }
    
    @keyframes strobeFlash {
      0% { 
        background: #0066ff;
        box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7), 0 0 60px rgba(0, 102, 255, 0.5);
        transform: scale(1);
      }
      50% { 
        background: #66ccff;
        box-shadow: 0 0 30px #66ccff, 0 0 60px rgba(102, 204, 255, 1), 0 0 90px rgba(102, 204, 255, 0.8);
        transform: scale(1.1);
      }
      100% { 
        background: #0066ff;
        box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7), 0 0 60px rgba(0, 102, 255, 0.5);
        transform: scale(1);
      }
    }

    /* Game UI - responsive positioning */
    #gameUI {
      position: fixed;
      top: 15px;
      left: 15px;
      color: #eee;
      font-weight: 600;
      z-index: 1100;
      user-select: none;
      display: none;
      font-size: clamp(0.9rem, 3vw, 1rem);
    }

    #score {
      margin-bottom: 5px;
      color: #bb86fc;
    }

    /* Fun Mode Button - responsive */
    #funModeBtn {
      position: fixed;
      top: 15px;
      right: 15px;
      background-color: #3700b3;
      color: #eee;
      border: none;
      padding: clamp(6px, 2vw, 8px) clamp(10px, 3vw, 15px);
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1100;
      user-select: none;
      transition: background-color 0.3s ease;
      font-size: clamp(0.8rem, 2.5vw, 1rem);
    }
    
    #funModeBtn:hover {
      background-color: #6200ee;
    }

    /* Touch controls for mobile */
    #touchControls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 1100;
      opacity: 0.7;
    }

    .touch-btn {
      background-color: rgba(187, 134, 252, 0.3);
      border: 2px solid #bb86fc;
      color: #eee;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background-color: rgba(187, 134, 252, 0.6);
      transform: scale(0.95);
    }

    .touch-btn-row {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* Instructions for mobile */
    #mobileInstructions {
      position: fixed;
      bottom: 80px;
      left: 15px;
      right: 15px;
      background-color: rgba(30, 30, 30, 0.9);
      color: #eee;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.9rem;
      text-align: center;
      z-index: 1100;
      display: none;
    }

    /* Tablet and mobile specific adjustments */
    @media (max-width: 768px) {
      body {
        padding: 15px 10px;
      }
      
      section {
        padding: 15px;
        margin-top: 20px;
      }
      
      #text {
        margin-bottom: 15px;
      }
      
      h2 {
        margin-top: 25px;
        font-size: clamp(1.1rem, 5vw, 1.4rem);
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 10px 5px;
      }
      
      section {
        padding: 12px;
        margin-top: 15px;
      }
      
      #funModeBtn {
        padding: 6px 10px;
        font-size: 0.8rem;
      }
      
      #gameUI {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>

  <div id="gameUI">
    <div id="score">Score: 0</div>
  </div>

  <button id="funModeBtn">Enter Fun Mode</button>

  <!-- Touch controls for mobile -->
  <div id="touchControls">
    <div class="touch-btn-row">
      <div class="touch-btn" data-direction="up">‚Üë</div>
    </div>
    <div class="touch-btn-row">
      <div class="touch-btn" data-direction="left">‚Üê</div>
      <div class="touch-btn" data-direction="right">‚Üí</div>
    </div>
    <div class="touch-btn-row">
      <div class="touch-btn" data-direction="down">‚Üì</div>
    </div>
  </div>

  <div id="mobileInstructions">
    Drag the monster around to catch enemies! Use arrow buttons or drag to move.
  </div>

  <div id="text">Ian Ryan Smith - Portfolio</div>

  <p>
    Motivated and adaptable professional with a background in digital marketing, recruitment, and sales actively trying to pivot to cyber security. Exploring technology and applying skills through projects and certifications.
  </p>

  <section>
    <h2>View My CV</h2>
    <ul>
      <li><a href="https://docs.google.com/document/d/17sufq0eM3QovPwR0BcW_YN1xdxzJYsTGO_HJaNaaT5g/edit?usp=sharing" target="_blank" rel="noopener">Click Here To View</a></li>
    </ul>
  </section>

  <section>
    <h2>Projects & Code</h2>
    <ul>
      <li><a href="https://github.com/illestonline" target="_blank" rel="noopener">My GitHub Profile</a></li>
    </ul>
  </section>

  <section>
    <h2>Online Learning & Certificates</h2>
    <ul>
      <li><a href="https://github.com/illestonline/networking-notes/blob/main/Certifications.md" target="_blank" rel="noopener">View My Certificates</a></li>
    </ul>
  </section>

  <section>
    <h2>Contact</h2>
    <ul>
      <li>Email: <a href="mailto:ianryansmith@gmail.com">Click Here To Email Me</a></li>
      <li>LinkedIn: <a href="https://www.linkedin.com/in/ian-smith-283410bb/" target="_blank" rel="noopener">Click Here To View</a></li>
    </ul>
  </section>

  <div id="car">üëæ</div>

  <script>
    const car = document.getElementById('car');
    const text = document.getElementById('text');
    const funModeBtn = document.getElementById('funModeBtn');
    const gameUI = document.getElementById('gameUI');
    const scoreEl = document.getElementById('score');
    const touchControls = document.getElementById('touchControls');
    const mobileInstructions = document.getElementById('mobileInstructions');

    let letters = [];
    let enemies = [];
    let funModeOn = false;
    let animationFrameId;
    let score = 0;
    let enemySpawnTimer = 0;
    let enemySpawnRate = 240;
    let isMobile = 'ontouchstart' in window;

    // Touch and drag variables
    let isDragging = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let carStartX = 0;
    let carStartY = 0;

    function wrapLetters(element) {
      const content = element.textContent;
      element.textContent = '';
      let spans = [];
      for (let char of content) {
        const span = document.createElement('span');
        span.textContent = char;
        if (char === ' ') {
          span.classList.add('space');
        }
        element.appendChild(span);
        spans.push(span);
      }
      return spans;
    }

    letters = wrapLetters(text);
    const headings = document.querySelectorAll('h2');
    headings.forEach(h2 => {
      const h2Letters = wrapLetters(h2);
      letters = letters.concat(h2Letters);
    });

    let carPos = { x: 20, y: window.innerHeight - 70 };
    let speed = 3;
    let velocity = { x: 0, y: 0 };
    let currentDir = null;
    let speedDoubled = false;

    const directions = {
      ArrowLeft: { x: -1, y: 0, opposite: 'ArrowRight' },
      ArrowRight: { x: 1, y: 0, opposite: 'ArrowLeft' },
      ArrowUp: { x: 0, y: -1, opposite: 'ArrowDown' },
      ArrowDown: { x: 0, y: 1, opposite: 'ArrowUp' },
      up: { x: 0, y: -1, opposite: 'down' },
      down: { x: 0, y: 1, opposite: 'up' },
      left: { x: -1, y: 0, opposite: 'right' },
      right: { x: 1, y: 0, opposite: 'left' }
    };

    function createEnemy() {
      const enemy = document.createElement('div');
      
      let enemyType = 'normal';
      
      if (score >= 300 && Math.random() < 0.10) {
        enemyType = 'boss';
      } else if (score >= 100 && Math.random() < 0.30) {
        enemyType = 'special';
      }
      
      const screenWidth = window.innerWidth;
      const enemySize = enemyType === 'boss' ? 25 : (enemyType === 'special' ? 7.5 : 20);
      
      if (enemyType === 'boss') {
        enemy.className = 'boss-enemy';
      } else if (enemyType === 'special') {
        enemy.className = 'special-enemy';
      } else {
        enemy.className = 'enemy';
      }
      
      enemy.style.left = (Math.random() * (screenWidth - enemySize)) + 'px';
      enemy.style.top = '-30px';
      document.body.appendChild(enemy);
      
      let baseSpeed;
      if (score < 150) {
        baseSpeed = (0.5 + Math.random() * 0.5) * 0.75;
      } else if (score < 400) {
        const speedMultiplier = 1 + Math.min((score - 150) / 200, 1.5);
        baseSpeed = (0.8 + Math.random() * 0.7) * speedMultiplier * 0.75;
      } else {
        const speedMultiplier = 1 + Math.min((score - 150) / 200, 1.5);
        const bonusSpeedMultiplier = 1 + Math.min((score - 400) / 300, 1.0);
        baseSpeed = (0.8 + Math.random() * 0.7) * speedMultiplier * bonusSpeedMultiplier * 0.75;
      }
      
      if (enemyType === 'boss') {
        baseSpeed *= 2.2;
      } else if (enemyType === 'special') {
        baseSpeed *= 2;
      }
      
      enemies.push({
        element: enemy,
        x: parseFloat(enemy.style.left),
        y: -30,
        speed: baseSpeed,
        type: enemyType,
        horizontalVelocity: 0,
        lastTextCollision: 0
      });
    }

    function updateEnemies() {
      enemies.forEach((enemy, index) => {
        enemy.y += enemy.speed;
        enemy.x += enemy.horizontalVelocity;
        
        if (enemy.x <= 0 || enemy.x >= window.innerWidth - 20) {
          enemy.horizontalVelocity *= -0.5;
        }
        enemy.x = Math.max(0, Math.min(window.innerWidth - 20, enemy.x));
        
        enemy.element.style.top = enemy.y + 'px';
        enemy.element.style.left = enemy.x + 'px';
        
        if (enemy.y > window.innerHeight) {
          enemy.element.remove();
          let penalty = enemy.type === 'boss' ? -50 : (enemy.type === 'special' ? -30 : -10);
          enemies.splice(index, 1);
          score = Math.max(0, score + penalty);
          scoreEl.textContent = 'Score: ' + score;
          updateSpawnRate();
        }
      });
    }

    function checkEnemyCollisions() {
      const carRect = car.getBoundingClientRect();
      
      enemies.forEach((enemy, index) => {
        const enemyRect = enemy.element.getBoundingClientRect();
        if (rectsOverlap(carRect, enemyRect)) {
          let points = enemy.type === 'boss' ? 50 : (enemy.type === 'special' ? 30 : 10);
          enemy.element.remove();
          enemies.splice(index, 1);
          score += points;
          scoreEl.textContent = 'Score: ' + score;
          updateSpawnRate();
        }
      });
    }

    function updateSpawnRate() {
      const scoreThreshold = Math.floor(score / 50);
      let newSpawnRate = Math.max(90, 240 - (scoreThreshold * 20));
      
      if (score >= 200) {
        const bonusEnemyTiers = Math.floor((score - 200) / 100);
        const bonusReduction = bonusEnemyTiers * 15;
        newSpawnRate = Math.max(45, newSpawnRate - bonusReduction);
      }
      
      enemySpawnRate = newSpawnRate;
    }

    function rectsOverlap(r1, r2) {
      return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
    }

    function knockOverLetter(letter, impactX, impactY, force) {
      if (letter.dataset.knocked === 'true') return;
      letter.dataset.knocked = 'true';

      let moveX = (impactX > 0 ? 1 : -1) * 40 * force;
      let moveY = (impactY > 0 ? 1 : -1) * 40 * force;
      let rotate = (impactX !== 0 ? moveX : moveY) * 0.5;

      letter.style.transition = 'transform 0.1s ease-out';
      letter.style.transform = `translate(${moveX}px, ${moveY}px) rotate(${rotate}deg)`;

      setTimeout(() => {
        letter.style.transition = 'transform 0.3s ease-in';
        letter.style.transform = 'translate(0, 0) rotate(0deg)';
        setTimeout(() => {
          letter.style.transition = 'transform 0.15s ease-in-out';
          letter.style.transform = 'rotate(12deg)';
          setTimeout(() => {
            letter.style.transform = 'rotate(-8deg)';
            setTimeout(() => {
              letter.style.transform = 'rotate(5deg)';
              setTimeout(() => {
                letter.style.transform = 'rotate(0deg)';
                letter.dataset.knocked = 'false';
              }, 100);
            }, 100);
          }, 100);
        }, 350);
      }, 100);
    }

    function update() {
      if (!funModeOn) return;

      carPos.x += velocity.x;
      carPos.y += velocity.y;

      carPos.x = Math.max(0, Math.min(window.innerWidth - car.offsetWidth, carPos.x));
      carPos.y = Math.max(0, Math.min(window.innerHeight - car.offsetHeight, carPos.y));

      car.style.left = carPos.x + 'px';
      car.style.top = carPos.y + 'px';

      updateEnemies();
      checkEnemyCollisions();

      enemySpawnTimer++;
      if (enemySpawnTimer >= enemySpawnRate) {
        createEnemy();
        enemySpawnTimer = 0;
      }

      const carRect = car.getBoundingClientRect();
      letters.forEach(letter => {
        const letterRect = letter.getBoundingClientRect();
        if (rectsOverlap(carRect, letterRect)) {
          const dx = letterRect.left + letterRect.width / 2 - (carRect.left + carRect.width / 2);
          const dy = letterRect.top + letterRect.height / 2 - (carRect.top + carRect.height / 2);
          knockOverLetter(letter, dx, dy, speedDoubled ? 2 : 1);
        }
      });

      const currentTime = Date.now();
      enemies.forEach((enemy, enemyIndex) => {
        const enemyRect = enemy.element.getBoundingClientRect();
        letters.forEach(letter => {
          const letterRect = letter.getBoundingClientRect();
          if (rectsOverlap(enemyRect, letterRect)) {
            if (currentTime - enemy.lastTextCollision > 200) {
              const dx = letterRect.left + letterRect.width / 2 - (enemyRect.left + enemyRect.width / 2);
              const dy = letterRect.top + letterRect.height / 2 - (enemyRect.top + enemyRect.height / 2);
              
              let force = enemy.speed * 0.3;
              if (enemy.type === 'boss') {
                force *= 1.5;
              } else if (enemy.type === 'special') {
                force *= 1.2;
              }
              knockOverLetter(letter, dx, dy, force);
              
              const randomDirection = (Math.random() - 0.5) * 2;
              const velocityChange = randomDirection * (1 + Math.random() * 2);
              enemy.horizontalVelocity += velocityChange;
              
              const maxHorizontalSpeed = enemy.speed * 0.8;
              enemy.horizontalVelocity = Math.max(-maxHorizontalSpeed, Math.min(maxHorizontalSpeed, enemy.horizontalVelocity));
              
              enemy.lastTextCollision = currentTime;
            }
          }
        });
      });

      animationFrameId = requestAnimationFrame(update);
    }

    // Touch and drag controls
    function handleTouchStart(e) {
      if (!funModeOn) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const carRect = car.getBoundingClientRect();
      
      // Check if touch is on the car
      if (touch.clientX >= carRect.left && touch.clientX <= carRect.right &&
          touch.clientY >= carRect.top && touch.clientY <= carRect.bottom) {
        isDragging = true;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        carStartX = carPos.x;
        carStartY = carPos.y;
        
        // Stop current movement
        velocity.x = 0;
        velocity.y = 0;
        currentDir = null;
        speed = 3;
        speedDoubled = false;
      }
    }

    function handleTouchMove(e) {
      if (!funModeOn || !isDragging) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      
      carPos.x = carStartX + deltaX;
      carPos.y = carStartY + deltaY;
      
      // Keep car within bounds
      carPos.x = Math.max(0, Math.min(window.innerWidth - car.offsetWidth, carPos.x));
      carPos.y = Math.max(0, Math.min(window.innerHeight - car.offsetHeight, carPos.y));
    }

    function handleTouchEnd(e) {
      isDragging = false;
    }

    // Touch button controls
    function handleTouchButton(direction) {
      if (!funModeOn) return;
      
      if (currentDir === direction) {
        if (!speedDoubled) {
          speed *= 2;
          speedDoubled = true;
          velocity.x = directions[direction].x * speed;
          velocity.y = directions[direction].y * speed;
        }
        return;
      }

      if (currentDir === directions[direction].opposite) {
        velocity.x = 0;
        velocity.y = 0;
        currentDir = null;
        speed = 3;
        speedDoubled = false;
        return;
      }

      currentDir = direction;
      speed = 3;
      speedDoubled = false;
      velocity.x = directions[direction].x * speed;
      velocity.y = directions[direction].y * speed;
    }

    // Event listeners
    if (isMobile) {
      // Touch events for dragging
      car.addEventListener('touchstart', handleTouchStart, { passive: false });
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // Touch button events
      document.querySelectorAll('.touch-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          handleTouchButton(btn.dataset.direction);
        }, { passive: false });
        
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          if (currentDir === btn.dataset.direction) {
            velocity.x = 0;
            velocity.y = 0;
            currentDir = null;
            speed = 3;
            speedDoubled = false;
          }
        }, { passive: false });
      });
    }

    // Keyboard controls for desktop
    window.addEventListener('keydown', (e) => {
      if (!funModeOn) return;
      if (!directions[e.key]) return;

      if (currentDir === e.key) {
        if (!speedDoubled) {
          speed *= 2;
          speedDoubled = true;
          velocity.x = directions[e.key].x * speed;
          velocity.y = directions[e.key].y * speed;
        }
        return;
      }

      if (currentDir === directions[e.key].opposite) {
        velocity.x = 0;
        velocity.y = 0;
        currentDir = null;
        speed = 3;
        speedDoubled = false;
        return;
      }

      currentDir = e.key;
      speed = 3;
      speedDoubled = false;
      velocity.x = directions[e.key].x * speed;
      velocity.y = directions[e.key].y * speed;
    });

    window.addEventListener('keyup', (e) => {
      if (!funModeOn) return;
      if (e.key === currentDir) {
        velocity.x = 0;
        velocity.y = 0;
        currentDir = null;
        speed = 3;
        speedDoubled = false;
      }
    });

    // Fun Mode toggle
    funModeBtn.addEventListener('click', () => {
      funModeOn = !funModeOn;
      if (funModeOn) {
        funModeBtn.textContent = 'Exit Fun Mode';
        gameUI.style.display = 'block';
        car.style.display = 'block';
        car.style.pointerEvents = 'auto'; // Enable touch interaction
        
        if (isMobile) {
          touchControls.style.display = 'flex';
          mobileInstructions.style.display = 'block';
          // Hide instructions after 3 seconds
          setTimeout(() => {
            mobileInstructions.style.display = 'none';
          }, 3000);
        }
        
        animationFrameId = requestAnimationFrame(update);
      } else {
        funModeBtn.textContent = 'Enter Fun Mode';
        gameUI.style.display = 'none';
        car.style.display = 'none';
        car.style.pointerEvents = 'none';
        
        if (isMobile) {
          touchControls.style.display = 'none';
          mobileInstructions.style.display = 'none';
        }
        
        cancelAnimationFrame(animationFrameId);
        
        // Reset all letters
        letters.forEach(letter => {
          letter.style.transition = '';
          letter.style.transform = '';
          letter.dataset.knocked = 'false';
        });
        
        // Remove all enemies
        enemies.forEach(enemy => enemy.element.remove());
        enemies = [];
        velocity.x = 0;
        velocity.y = 0;
        isDragging = false;
        
        // Reset game state
        score = 0;
        enemySpawnRate = 240;
        scoreEl.textContent = 'Score: 0';
        
        // Reset car position
        carPos = { x: 20, y: window.innerHeight - 70 };
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      carPos.x = Math.min(carPos.x, window.innerWidth - car.offsetWidth);
      carPos.y = Math.min(carPos.y, window.innerHeight - car.offsetHeight);
      
      // Update car position on screen
      if (funModeOn) {
        car.style.left = carPos.x + 'px';
        car.style.top = carPos.y + 'px';
      }
    });

    // Prevent default touch behaviors that might interfere with the game
    document.addEventListener('touchstart', (e) => {
      if (funModeOn && (e.target === car || e.target.classList.contains('touch-btn'))) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (funModeOn && isDragging) {
        e.preventDefault();
      }
    }, { passive: false });

  </script>

</body>
</html>
          

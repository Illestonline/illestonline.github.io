
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ian Ryan Smith - Portfolio</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', Arial, sans-serif;
      max-width: 800px;
      margin: 20px auto;
      padding: 15px;
      color: #eee;
      background-color: #121212;
      line-height: 1.6;
      position: relative;
    }
    
    h2 {
      color: #bb86fc;
      margin-top: 30px;
      border-bottom: 2px solid #333;
      padding-bottom: 6px;
      user-select: none;
      white-space: nowrap;
      font-size: 1.5rem;
    }
    
    section {
      background-color: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(187, 134, 252, 0.3);
      margin-top: 20px;
    }
    
    a {
      color: #bb86fc;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s ease;
      word-break: break-word;
    }
    
    a:hover,
    a:focus {
      color: #3700b3;
      text-decoration: underline;
    }
    
    ul {
      list-style: none;
      padding-left: 0;
    }
    
    li {
      margin-bottom: 12px;
    }
    
    p {
      font-size: 1.1rem;
      margin-top: 10px;
    }
    
    /* Main header */
    #text {
      font-size: 2.5rem;
      user-select: none;
      white-space: nowrap;
      font-weight: 700;
      color: #bb86fc;
      margin-bottom: 20px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 5px;
    }
    
    #text span,
    h2 span {
      display: inline-block;
      transition: transform 0.1s ease-in-out;
      cursor: default;
    }
    
    #text span.space,
    h2 span.space {
      width: 0.3em;
    }
    
    #text span.destroyed,
    h2 span.destroyed {
      opacity: 0;
      color: #ff4444;
      text-shadow: 0 0 10px #ff4444;
      transition: opacity 0.3s ease-out, color 0.3s ease-out, text-shadow 0.3s ease-out;
    }
    
    /* Car - much larger on mobile */
    #car {
      position: fixed;
      width: 80px;
      height: 40px;
      bottom: 20px;
      left: 20px;
      background: transparent;
      border-radius: 10px;
      z-index: 1001;
      user-select: none;
      pointer-events: none;
      display: none;
      font-size: 40px;
      line-height: 40px;
      text-align: center;
    }
    
    /* Enemies - smaller on mobile */
    .enemy {
      position: fixed;
      width: 15px;
      height: 15px;
      background: #ff4444;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 8px #ff4444;
      user-select: none;
      pointer-events: none;
    }
    
    .special-enemy {
      position: fixed;
      width: 6px;
      height: 6px;
      background: #ffaa00;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 15px #ffaa00, 0 0 30px rgba(255, 170, 0, 0.5);
      user-select: none;
      pointer-events: none;
      animation: dramaticPulse 0.5s infinite alternate ease-in-out;
    }
    
    @keyframes dramaticPulse {
      0% { 
        transform: scale(0.8);
        box-shadow: 0 0 10px #ffaa00, 0 0 20px rgba(255, 170, 0, 0.3);
      }
      100% { 
        transform: scale(2.2);
        box-shadow: 0 0 25px #ffaa00, 0 0 50px rgba(255, 170, 0, 0.8), 0 0 75px rgba(255, 170, 0, 0.4);
      }
    }

    .boss-enemy {
      position: fixed;
      width: 18px;
      height: 18px;
      background: #0066ff;
      border-radius: 50%;
      z-index: 1000;
      box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7);
      user-select: none;
      pointer-events: none;
      animation: strobeFlash 0.1s infinite steps(2, start);
    }
    
    @keyframes strobeFlash {
      0% { 
        background: #0066ff;
        box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7), 0 0 60px rgba(0, 102, 255, 0.5);
        transform: scale(1);
      }
      50% { 
        background: #66ccff;
        box-shadow: 0 0 30px #66ccff, 0 0 60px rgba(102, 204, 255, 1), 0 0 90px rgba(102, 204, 255, 0.8);
        transform: scale(1.1);
      }
      100% { 
        background: #0066ff;
        box-shadow: 0 0 20px #0066ff, 0 0 40px rgba(0, 102, 255, 0.7), 0 0 60px rgba(0, 102, 255, 0.5);
        transform: scale(1);
      }
    }

    .particle {
      position: fixed;
      width: 3px;
      height: 3px;
      background: #bb86fc;
      border-radius: 50%;
      z-index: 999;
      box-shadow: 0 0 6px #bb86fc;
      user-select: none;
      pointer-events: none;
      animation: particleFade 0.8s ease-out forwards;
    }
    
    @keyframes particleFade {
      0% { 
        opacity: 1;
        transform: scale(1);
      }
      100% { 
        opacity: 0;
        transform: scale(0.3);
      }
    }

    /* Game UI */
    #gameUI {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #eee;
      font-weight: 600;
      z-index: 1100;
      user-select: none;
      display: none;
      font-size: 0.9rem;
    }

    #score {
      margin-bottom: 5px;
      color: #bb86fc;
    }

    /* Game Over Overlay */
    #gameOverOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      user-select: none;
      padding: 20px;
    }

    #gameOverContent {
      text-align: center;
      color: #eee;
      background: #1e1e1e;
      padding: 30px 20px;
      border-radius: 12px;
      border: 2px solid #ff4444;
      box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
      max-width: 90%;
      width: 400px;
    }

    #gameOverContent h1 {
      color: #ff4444;
      font-size: 2rem;
      margin-bottom: 15px;
      text-shadow: 0 0 15px #ff4444;
    }

    #gameOverContent p {
      font-size: 1rem;
      margin-bottom: 20px;
    }

    #restartBtn {
      background-color: #bb86fc;
      color: #121212;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.3s ease;
      touch-action: manipulation;
    }

    #restartBtn:hover {
      background-color: #6200ee;
      color: #eee;
    }

    /* Fun Mode Button - Enhanced for mobile */
    #funModeBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: #3700b3;
      color: #eee;
      border: none;
      padding: 12px 16px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1100;
      user-select: none;
      transition: background-color 0.3s ease;
      font-size: 0.9rem;
      touch-action: manipulation;
      min-height: 48px;
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #funModeBtn:hover {
      background-color: #6200ee;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      body {
        margin: 10px;
        padding: 10px;
      }
      
      #text {
        font-size: 1.8rem;
        margin-bottom: 15px;
      }
      
      h2 {
        font-size: 1.3rem;
        margin-top: 25px;
        white-space: normal; /* Allow wrapping on very small screens */
      }
      
      section {
        padding: 15px;
        margin-top: 15px;
      }
      
      p {
        font-size: 1rem;
      }
      
      /* Make car much larger on mobile - 3x the original size */
      #car {
        width: 180px;
        height: 120px;
        font-size: 120px;
        line-height: 120px;
      }
      
      .enemy {
        width: 12px;
        height: 12px;
      }
      
      .special-enemy {
        width: 5px;
        height: 5px;
      }
      
      .boss-enemy {
        width: 15px;
        height: 15px;
      }
      
      #gameOverContent {
        padding: 20px 15px;
      }
      
      #gameOverContent h1 {
        font-size: 1.5rem;
      }
      
      /* Enhanced mobile button styling */
      #funModeBtn {
        font-size: 0.85rem;
        padding: 14px 18px;
        min-height: 52px;
        min-width: 130px;
        border-radius: 10px;
      }
    }
    
    /* Extra small screens */
    @media (max-width: 480px) {
      #text {
        font-size: 1.5rem;
      }
      
      h2 {
        font-size: 1.2rem;
      }
      
      section {
        padding: 12px;
      }
      
      /* Even larger car for extra small screens */
      #car {
        width: 150px;
        height: 100px;
        font-size: 100px;
        line-height: 100px;
        bottom: 15px;
        left: 15px;
      }
      
      #gameUI {
        font-size: 0.8rem;
      }
      
      /* Maximum touch-friendly button on small screens */
      #funModeBtn {
        font-size: 0.8rem;
        padding: 16px 20px;
        min-height: 56px;
        min-width: 140px;
        border-radius: 12px;
      }
    }
    
    /* Touch-friendly improvements */
    @media (pointer: coarse) {
      a {
        padding: 8px 0;
        display: inline-block;
      }
      
      /* Ensure button is always touch-friendly */
      #funModeBtn {
        min-height: 48px;
        min-width: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
      }
      
      #restartBtn {
        min-height: 48px;
        padding: 14px 32px;
        font-size: 1.1rem;
      }
    }
    
    /* Landscape orientation on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      body {
        margin: 5px;
        padding: 5px;
      }
      
      #text {
        font-size: 1.6rem;
        margin-bottom: 10px;
      }
      
      section {
        padding: 10px;
        margin-top: 10px;
      }
      
      #car {
        width: 120px;
        height: 80px;
        font-size: 80px;
        line-height: 80px;
        bottom: 10px;
        left: 10px;
      }
      
      #gameUI {
        top: 5px;
        left: 5px;
      }
      
      #funModeBtn {
        top: 5px;
        right: 5px;
        min-height: 44px;
        padding: 12px 16px;
      }
    }
  </style>
</head>
<body>

  <div id="gameUI">
    <div id="score">Score: 0</div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay">
    <div id="gameOverContent">
      <h1>GAME OVER</h1>
      <p>All letters have been destroyed by enemies!</p>
      <p>Your final score: <span id="finalScore">0</span></p>
      <button id="restartBtn">Play Again</button>
    </div>
  </div>

  <button id="funModeBtn">Enter Fun Mode</button>

  <div id="text">Ian Ryan Smith - Portfolio</div>

  <p>
    Motivated and adaptable professional with a background in digital marketing, recruitment, and sales actively trying to pivot to cyber security. Exploring technology and applying skills through projects and certifications.
  </p>

  <section>
    <h2>View My CV</h2>
    <ul>
      <li><a href="https://docs.google.com/document/d/17sufq0eM3QovPwR0BcW_YN1xdxzJYsTGO_HJaNaaT5g/edit?usp=sharing" target="_blank" rel="noopener">Click Here To View</a></li>
    </ul>
  </section>

  <section>
    <h2>Projects & Code</h2>
    <ul>
      <li><a href="https://github.com/illestonline" target="_blank" rel="noopener">My GitHub Profile</a></li>
    </ul>
  </section>

  <section>
    <h2>Online Learning & Certificates</h2>
    <ul>
      <li><a href="https://github.com/Illestonline/networking-notes/blob/main/Certifications.md" target="_blank" rel="noopener">View My Certificates</a></li>
    </ul>
  </section>

  <section>
    <h2>Contact</h2>
    <ul>
      <li>Email: <a href="mailto:ianryansmith@gmail.com">Click Here To Email Me</a></li>
      <li>LinkedIn: <a href="https://www.linkedin.com/in/ian-smith-283410bb/" target="_blank" rel="noopener">Click Here To View</a></li>
    </ul>
  </section>

  <!-- Car now displays a bigger little monster -->
  <div id="car">ðŸ‘¾</div>


  <script>
    const car = document.getElementById('car');
const text = document.getElementById('text');
const funModeBtn = document.getElementById('funModeBtn');
const gameUI = document.getElementById('gameUI');
const scoreEl = document.getElementById('score');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

let letters = [];
let enemies = [];
let particles = [];
let funModeOn = false;
let animationFrameId;
let score = 0;
let enemySpawnTimer = 0;
let enemySpawnRate = 240; // frames between spawns (4 seconds at 60fps)
let gameOver = false;

// Wrap letters in #text and all h2 elements
function wrapLetters(element) {
  const content = element.textContent;
  element.textContent = '';
  let spans = [];
  for (let char of content) {
    const span = document.createElement('span');
    span.textContent = char;
    // Add class for spaces to make them visible
    if (char === ' ') {
      span.classList.add('space');
    }
    element.appendChild(span);
    spans.push(span);
  }
  return spans;
}

// Wrap main header letters
letters = wrapLetters(text);

// Wrap all h2 letters and add to letters array
const headings = document.querySelectorAll('h2');
headings.forEach(h2 => {
  const h2Letters = wrapLetters(h2);
  letters = letters.concat(h2Letters);
});

// Car position and movement variables
let carPos = { x: 20, y: window.innerHeight - 70 };
let baseSpeed = 3;
let currentSpeed = 3;
let maxSpeed = 6;
let velocity = { x: 0, y: 0 };
let keysPressed = new Set();
let accelerationTimer = 0;
let accelerationThreshold = 60; // frames before acceleration starts (1 second at 60fps)
let particleSpawnTimer = 0;

// Mouse movement variables with momentum
let mousePos = { x: 0, y: 0 };
let lastMousePos = { x: 0, y: 0 };
let mouseVelocity = { x: 0, y: 0 };
let isMouseMoving = false;
let mouseMovementTimer = 0;
let mouseMomentumDecay = 0.95; // How quickly momentum fades (0.95 = 5% decay per frame)
let minMomentum = 0.1; // Minimum momentum before stopping

// Touch support variables
let touchStartPos = { x: 0, y: 0 };
let touchCurrentPos = { x: 0, y: 0 };
let isTouching = false;

// Directions object for arrow keys
const directions = {
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 },
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 }
};

// Particle management
function createParticle() {
  const particle = document.createElement('div');
  particle.className = 'particle';
  
  // Spawn at car center with slight random offset
  const carRect = car.getBoundingClientRect();
  const carCenterX = carRect.left + carRect.width / 2;
  const carCenterY = carRect.top + carRect.height / 2;
  
  particle.style.left = (carCenterX + (Math.random() - 0.5) * 20) + 'px';
  particle.style.top = (carCenterY + (Math.random() - 0.5) * 20) + 'px';
  
  document.body.appendChild(particle);
  particles.push(particle);
  
  // Remove particle after animation completes
  setTimeout(() => {
    particle.remove();
    const index = particles.indexOf(particle);
    if (index > -1) {
      particles.splice(index, 1);
    }
  }, 800);
}

// Enemy management
function createEnemy() {
  const enemy = document.createElement('div');
  
  let enemyType = 'normal';
  
  // After 300 points, 10% chance for boss enemy (doubled from 5%)
  if (score >= 300 && Math.random() < 0.10) {
    enemyType = 'boss';
  }
  // After 100 points, 30% chance for special enemy (doubled from 15%, if not boss)
  else if (score >= 100 && Math.random() < 0.30) {
    enemyType = 'special';
  }
  
  // Calculate content area width (like the section boxes)
  const contentWidth = 800; // max-width of body
  const screenWidth = window.innerWidth;
  const availableWidth = Math.min(contentWidth, screenWidth - 40); // Account for margins
  const leftMargin = (screenWidth - availableWidth) / 2;
  
  if (enemyType === 'boss') {
    enemy.className = 'boss-enemy';
    enemy.style.left = (leftMargin + Math.random() * (availableWidth - 25)) + 'px';
  } else if (enemyType === 'special') {
    enemy.className = 'special-enemy';
    enemy.style.left = (leftMargin + Math.random() * (availableWidth - 7.5)) + 'px';
  } else {
    enemy.className = 'enemy';
    enemy.style.left = (leftMargin + Math.random() * (availableWidth - 20)) + 'px';
  }
  
  enemy.style.top = '-30px';
  document.body.appendChild(enemy);
  
  // Base enemy speed calculation - reduced by 25%
  let baseSpeed;
  if (score < 150) {
    baseSpeed = (0.5 + Math.random() * 0.5) * 0.75; // Reduced by 25%: 0.375-0.75
  } else if (score < 400) {
    const speedMultiplier = 1 + Math.min((score - 150) / 200, 1.5); // Gradually increase after 150 points
    baseSpeed = (0.8 + Math.random() * 0.7) * speedMultiplier * 0.75; // Reduced by 25%
  } else {
    // After 400 points, gradually increase speed again
    const speedMultiplier = 1 + Math.min((score - 150) / 200, 1.5);
    const bonusSpeedMultiplier = 1 + Math.min((score - 400) / 300, 1.0); // Additional multiplier after 400
    baseSpeed = (0.8 + Math.random() * 0.7) * speedMultiplier * bonusSpeedMultiplier * 0.75; // Still reduced by 25%
  }
  
  // Boss enemies are slightly faster than special, special enemies are fast
  if (enemyType === 'boss') {
    baseSpeed *= 2.2; // Only slightly faster than special enemies
  } else if (enemyType === 'special') {
    baseSpeed *= 2;
  }
  
  enemies.push({
    element: enemy,
    x: parseFloat(enemy.style.left),
    y: -30,
    speed: baseSpeed,
    type: enemyType,
    horizontalVelocity: 0, // Add horizontal movement capability
    lastTextCollision: 0 // Track when enemy last hit text to prevent constant direction changes
  });
}

function updateEnemies() {
  enemies.forEach((enemy, index) => {
    // Update vertical position (always falling)
    enemy.y += enemy.speed;
    
    // Update horizontal position
    enemy.x += enemy.horizontalVelocity;
    
    // Keep enemy within screen bounds horizontally
    if (enemy.x <= 0 || enemy.x >= window.innerWidth - 20) {
      enemy.horizontalVelocity *= -0.5; // Reverse and reduce horizontal velocity when hitting edges
    }
    enemy.x = Math.max(0, Math.min(window.innerWidth - 20, enemy.x));
    
    // Apply positions
    enemy.element.style.top = enemy.y + 'px';
    enemy.element.style.left = enemy.x + 'px';
    
    // Remove enemies that reached the bottom and decrease score
    if (enemy.y > window.innerHeight) {
      enemy.element.remove();
      let penalty;
      if (enemy.type === 'boss') {
        penalty = -50; // Boss enemies cost 5x more
      } else if (enemy.type === 'special') {
        penalty = -30; // Special enemies cost 3x more
      } else {
        penalty = -10; // Normal penalty
      }
      enemies.splice(index, 1);
      score = Math.max(0, score + penalty); // Add penalty (negative number)
      scoreEl.textContent = 'Score: ' + score;
      updateSpawnRate(); // Update spawn rate when score decreases
    }
  });
}

function checkEnemyCollisions() {
  const carRect = car.getBoundingClientRect();
  
  enemies.forEach((enemy, index) => {
    const enemyRect = enemy.element.getBoundingClientRect();
    if (rectsOverlap(carRect, enemyRect)) {
      // Enemy caught! Award points based on enemy type
      let points;
      if (enemy.type === 'boss') {
        points = 50; // Boss enemies worth 5x points
      } else if (enemy.type === 'special') {
        points = 30; // Special enemies worth 3x points
      } else {
        points = 10; // Normal points
      }
      enemy.element.remove();
      enemies.splice(index, 1);
      score += points;
      scoreEl.textContent = 'Score: ' + score;
      updateSpawnRate(); // Update spawn rate when score increases
    }
  });
}

// Update spawn rate based on current score
function updateSpawnRate() {
  const scoreThreshold = Math.floor(score / 50);
  let newSpawnRate = Math.max(90, 240 - (scoreThreshold * 20)); // Min 90 frames (1.5 seconds)
  
  // Add bonus enemies every 100 points after 200
  if (score >= 200) {
    const bonusEnemyTiers = Math.floor((score - 200) / 100);
    const bonusReduction = bonusEnemyTiers * 15; // Additional 15 frame reduction per tier
    newSpawnRate = Math.max(45, newSpawnRate - bonusReduction); // Min 45 frames (0.75 seconds)
  }
  
  enemySpawnRate = newSpawnRate;
}

function rectsOverlap(r1, r2) {
  return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
}

// Check if all knockable letters are destroyed
function checkGameOver() {
  if (gameOver) return; // Already game over
  
  // Count visible letters (not destroyed and not spaces)
  const visibleLetters = letters.filter(letter => 
    !letter.classList.contains('destroyed') && 
    !letter.classList.contains('space')
  );
  
  if (visibleLetters.length === 0) {
    gameOver = true;
    finalScoreEl.textContent = score;
    gameOverOverlay.style.display = 'flex';
    // Stop enemy spawning
    enemySpawnTimer = 0;
  }
}

// Knock over letter with bounce and wobble - UPDATED to handle enemy destruction
function knockOverLetter(letter, impactX, impactY, force, hitByEnemy = false) {
  if (letter.dataset.knocked === 'true' || letter.classList.contains('destroyed')) return;
  letter.dataset.knocked = 'true';

  if (hitByEnemy) {
    // Enemy hit - destroy the letter instead of bouncing
    letter.classList.add('destroyed');
    letter.dataset.knocked = 'false'; // Reset knocked state since it's destroyed
    
    // Check for game over after a short delay to let the animation start
    setTimeout(checkGameOver, 100);
    return;
  }

  // Car hit - normal bounce behavior
  let moveX = (impactX > 0 ? 1 : -1) * 40 * force;
  let moveY = (impactY > 0 ? 1 : -1) * 40 * force;
  let rotate = (impactX !== 0 ? moveX : moveY) * 0.5;

  letter.style.transition = 'transform 0.1s ease-out';
  letter.style.transform = `translate(${moveX}px, ${moveY}px) rotate(${rotate}deg)`;

  setTimeout(() => {
    letter.style.transition = 'transform 0.3s ease-in';
    letter.style.transform = 'translate(0, 0) rotate(0deg)';
    // Add wobble effect after return
    setTimeout(() => {
      letter.style.transition = 'transform 0.15s ease-in-out';
      letter.style.transform = 'rotate(12deg)';
      setTimeout(() => {
        letter.style.transform = 'rotate(-8deg)';
        setTimeout(() => {
          letter.style.transform = 'rotate(5deg)';
          setTimeout(() => {
            letter.style.transform = 'rotate(0deg)';
            letter.dataset.knocked = 'false';
          }, 100);
        }, 100);
      }, 100);
    }, 350);
  }, 100);
}

// Calculate normalized velocity for movement (updated for momentum-based mouse control and touch)
function updateVelocity() {
  let dirX = 0;
  let dirY = 0;
  let usingKeyboard = false;
  
  // Check if any movement keys are pressed (keyboard has priority)
  if (keysPressed.has('ArrowLeft')) { dirX -= 1; usingKeyboard = true; }
  if (keysPressed.has('ArrowRight')) { dirX += 1; usingKeyboard = true; }
  if (keysPressed.has('ArrowUp')) { dirY -= 1; usingKeyboard = true; }
  if (keysPressed.has('ArrowDown')) { dirY += 1; usingKeyboard = true; }
  
  // If no keyboard input, check for touch or mouse control
  if (!usingKeyboard) {
    const carCenterX = carPos.x + car.offsetWidth / 2;
    const carCenterY = carPos.y + car.offsetHeight / 2;
    
    let targetX, targetY;
    
    if (isTouching) {
      // Touch control - use touch position
      targetX = touchCurrentPos.x;
      targetY = touchCurrentPos.y;
    } else if (isMouseMoving && mouseMovementTimer > 0) {
      // Mouse control - use mouse position
      targetX = mousePos.x;
      targetY = mousePos.y;
    }
    
    if (targetX !== undefined && targetY !== undefined) {
      const dx = targetX - carCenterX;
      const dy = targetY - carCenterY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Only move if target is more than 10 pixels away (dead zone)
      if (distance > 10) {
        dirX = dx / distance;
        dirY = dy / distance;
        
        // Scale movement based on distance (closer = slower)
        const speedScale = Math.min(distance / 100, 1);
        dirX *= speedScale;
        dirY *= speedScale;
        
        // Update mouse velocity for momentum (only for mouse, not touch)
        if (!isTouching) {
          mouseVelocity.x = dirX;
          mouseVelocity.y = dirY;
        }
      }
    }
    
    // Check for momentum (only when not touching)
    if (!isTouching) {
      const momentumMagnitude = Math.sqrt(mouseVelocity.x * mouseVelocity.x + mouseVelocity.y * mouseVelocity.y);
      
      if (momentumMagnitude > minMomentum) {
        // Use momentum if we have it and no active input
        if (!isMouseMoving || mouseMovementTimer <= 0) {
          dirX = mouseVelocity.x;
          dirY = mouseVelocity.y;
        }
        
        // Always apply decay to momentum
        mouseVelocity.x *= mouseMomentumDecay;
        mouseVelocity.y *= mouseMomentumDecay;
      } else {
        // Stop momentum when it gets too small
        mouseVelocity.x = 0;
        mouseVelocity.y = 0;
      }
    }
  } else {
    // Reset mouse momentum when using keyboard
    mouseVelocity.x = 0;
    mouseVelocity.y = 0;
  }
  
  // Normalize diagonal movement for keyboard only
  if (usingKeyboard && dirX !== 0 && dirY !== 0) {
    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
    dirX /= magnitude;
    dirY /= magnitude;
  }
  
  // Apply current speed
  velocity.x = dirX * currentSpeed;
  velocity.y = dirY * currentSpeed;
  
  // Handle acceleration
  if (dirX !== 0 || dirY !== 0) {
    accelerationTimer++;
    if (accelerationTimer >= accelerationThreshold) {
      // Smooth acceleration from base speed to max speed
      if (currentSpeed < maxSpeed) {
        currentSpeed = Math.min(maxSpeed, currentSpeed + 0.1);
      }
    }
  } else {
    // Reset when not moving
    accelerationTimer = 0;
    currentSpeed = baseSpeed;
  }
}

// Reset game state
function resetGame() {
  // Reset game variables
  gameOver = false;
  score = 0;
  enemySpawnRate = 240;
  enemySpawnTimer = 0;
  scoreEl.textContent = 'Score: 0';
  
  // Remove all enemies
  enemies.forEach(enemy => enemy.element.remove());
  enemies = [];
  
  // Remove all particles
  particles.forEach(particle => particle.remove());
  particles = [];
  
  // Reset all letters - remove destroyed class and reset transforms
  letters.forEach(letter => {
    letter.classList.remove('destroyed');
    letter.style.transition = '';
    letter.style.transform = '';
    letter.dataset.knocked = 'false';
  });
  
  // Reset movement state
  keysPressed.clear();
  velocity.x = 0;
  velocity.y = 0;
  currentSpeed = baseSpeed;
  accelerationTimer = 0;
  particleSpawnTimer = 0;
  
  // Reset mouse state and momentum
  isMouseMoving = false;
  mouseMovementTimer = 0;
  mouseVelocity.x = 0;
  mouseVelocity.y = 0;
  
  // Reset touch state
  isTouching = false;
  
  // Reset car position
  carPos.x = 20;
  carPos.y = window.innerHeight - 70;
  car.style.left = carPos.x + 'px';
  car.style.top = carPos.y + 'px';
  
  // Hide game over overlay
  gameOverOverlay.style.display = 'none';
}

// Main update loop to move car and check collisions
function update() {
  if (!funModeOn || gameOver) return;

  // Update mouse movement timer
  if (isMouseMoving) {
    mouseMovementTimer--;
    if (mouseMovementTimer <= 0) {
      isMouseMoving = false;
    }
  }

  // Update velocity based on current input (keyboard, mouse with momentum, or touch)
  updateVelocity();

  carPos.x += velocity.x;
  carPos.y += velocity.y;

  // Constrain car inside viewport
  carPos.x = Math.max(0, Math.min(window.innerWidth - car.offsetWidth, carPos.x));
  carPos.y = Math.max(0, Math.min(window.innerHeight - car.offsetHeight, carPos.y));

  car.style.left = carPos.x + 'px';
  car.style.top = carPos.y + 'px';

  // Spawn particles when at full speed and moving
  if (currentSpeed >= maxSpeed && (velocity.x !== 0 || velocity.y !== 0)) {
    particleSpawnTimer++;
    if (particleSpawnTimer >= 3) { // Spawn every 3 frames at full speed
      createParticle();
      particleSpawnTimer = 0;
    }
  } else {
    particleSpawnTimer = 0;
  }

  // Update enemies
  updateEnemies();
  checkEnemyCollisions();

  // Spawn enemies (only if game is not over)
  if (!gameOver) {
    enemySpawnTimer++;
    if (enemySpawnTimer >= enemySpawnRate) {
      createEnemy();
      enemySpawnTimer = 0;
    }
  }

  // Check letter collisions (original functionality for car)
  const carRect = car.getBoundingClientRect();
  letters.forEach(letter => {
    if (letter.classList.contains('destroyed')) return; // Skip destroyed letters
    
    const letterRect = letter.getBoundingClientRect();
    if (rectsOverlap(carRect, letterRect)) {
      const dx = letterRect.left + letterRect.width / 2 - (carRect.left + carRect.width / 2);
      const dy = letterRect.top + letterRect.height / 2 - (carRect.top + carRect.height / 2);
      knockOverLetter(letter, dx, dy, currentSpeed >= maxSpeed ? 2 : 1, false); // false = hit by car
    }
  });

  // Check enemy-letter collisions - enemies destroy letters
  const currentTime = Date.now();
  enemies.forEach((enemy, enemyIndex) => {
    const enemyRect = enemy.element.getBoundingClientRect();
    letters.forEach(letter => {
      if (letter.classList.contains('destroyed')) return; // Skip already destroyed letters
      
      const letterRect = letter.getBoundingClientRect();
      if (rectsOverlap(enemyRect, letterRect)) {
        // Only process collision if enough time has passed since last collision (prevent spam)
        if (currentTime - enemy.lastTextCollision > 200) { // 200ms cooldown
          const dx = letterRect.left + letterRect.width / 2 - (enemyRect.left + enemyRect.width / 2);
          const dy = letterRect.top + letterRect.height / 2 - (enemyRect.top + enemyRect.height / 2);
          
          // Force based on enemy speed and type for letter knock-over/destruction
          let force = enemy.speed * 0.3;
          if (enemy.type === 'boss') {
            force *= 1.5; // Boss enemies have stronger impact
          } else if (enemy.type === 'special') {
            force *= 1.2; // Special enemies have medium impact
          }
          
          // Enemy destroys the letter instead of just knocking it over
          knockOverLetter(letter, dx, dy, force, true); // true = hit by enemy
          
          // Add random horizontal velocity change for enemy
          const randomDirection = (Math.random() - 0.5) * 2; // Random value between -1 and 1
          const velocityChange = randomDirection * (1 + Math.random() * 2); // Random velocity between -3 and 3
          enemy.horizontalVelocity += velocityChange;
          
          // Cap horizontal velocity to prevent enemies from moving too fast horizontally
          const maxHorizontalSpeed = enemy.speed * 0.8;
          enemy.horizontalVelocity = Math.max(-maxHorizontalSpeed, Math.min(maxHorizontalSpeed, enemy.horizontalVelocity));
          
          // Update last collision time
          enemy.lastTextCollision = currentTime;
        }
      }
    });
  });

  animationFrameId = requestAnimationFrame(update);
}

// Touch event listeners
window.addEventListener('touchstart', (e) => {
  if (!funModeOn) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  touchStartPos.x = touch.clientX;
  touchStartPos.y = touch.clientY;
  touchCurrentPos.x = touch.clientX;
  touchCurrentPos.y = touch.clientY;
  isTouching = true;
}, { passive: false });

window.addEventListener('touchmove', (e) => {
  if (!funModeOn || !isTouching) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  touchCurrentPos.x = touch.clientX;
  touchCurrentPos.y = touch.clientY;
}, { passive: false });

window.addEventListener('touchend', (e) => {
  if (!funModeOn) return;
  e.preventDefault();
  
  isTouching = false;
}, { passive: false });

// Mouse event listeners with momentum tracking
window.addEventListener('mousemove', (e) => {
  if (!funModeOn) return;
  
  // Store last position for momentum calculation
  lastMousePos.x = mousePos.x;
  lastMousePos.y = mousePos.y;
  
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;
  isMouseMoving = true;
  mouseMovementTimer = 30; // Reset timer (0.5 seconds at 60fps)
});

window.addEventListener('mouseenter', (e) => {
  if (!funModeOn) return;
  
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;
});

// Keyboard event listeners for movement
window.addEventListener('keydown', (e) => {
  if (!funModeOn) return;
  if (!directions[e.key]) return;
  e.preventDefault();
  
  keysPressed.add(e.key);
});

window.addEventListener('keyup', (e) => {
  if (!funModeOn) return;
  if (!directions[e.key]) return;
  e.preventDefault();
  
  keysPressed.delete(e.key);
});

// Restart button event listener
restartBtn.addEventListener('click', () => {
  resetGame();
});

// Toggle Fun Mode button
funModeBtn.addEventListener('click', () => {
  funModeOn = !funModeOn;
  if (funModeOn) {
    funModeBtn.textContent = 'Exit Fun Mode';
    gameUI.style.display = 'block'; // Show game UI
    car.style.display = 'block'; // Show the car
    resetGame(); // Reset game state when entering fun mode
    animationFrameId = requestAnimationFrame(update);
  } else {
    funModeBtn.textContent = 'Enter Fun Mode';
    gameUI.style.display = 'none'; // Hide game UI
    gameOverOverlay.style.display = 'none'; // Hide game over screen
    car.style.display = 'none'; // Hide the car
    cancelAnimationFrame(animationFrameId);
    resetGame(); // Reset everything when exiting
  }
});

// Update car position on window resize to keep it on screen
window.addEventListener('resize', () => {
  carPos.x = Math.min(carPos.x, window.innerWidth - car.offsetWidth);
  carPos.y = Math.min(carPos.y, window.innerHeight - car.offsetHeight);
});
  </script>

</body>
</html>
